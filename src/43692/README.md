# 43692 - 青蛙跳杯子

![Year: 2017](https://img.shields.io/badge/Year-2017-white)
![Level: Provincial](https://img.shields.io/badge/Level-Provincial-blue)
![Java11](https://img.shields.io/badge/Java11-AC-green)
![Python3](https://img.shields.io/badge/Python3-AC-green)
![PyPy7](https://img.shields.io/badge/PyPy7-AC-green)

## 题目

### 题目描述

$X$ 星球的流行宠物是青蛙，一般有两种颜色：白色和黑色。

$X$ 星球的居民喜欢把它们放在一排茶杯里，这样可以观察它们跳来跳去。

如下图，有一排杯子，左边的一个是空着的，右边的杯子，每个里边有一只青蛙。

$*WWWBBB$

其中， $W$ 字母表示白色青蛙， $B$ 表示黑色青蛙， $*$ 表示空杯子。

$X$ 星的青蛙很有些癖好，它们只做 3 个动作之一：

1. 跳到相邻的空杯子里。
2. 隔着 1 只其它的青蛙（随便什么颜色）跳到空杯子里。
3. 隔着 2 只其它的青蛙（随便什么颜色）跳到空杯子里。

对于上图的局面，只要 1 步，就可跳成下图局面：

$WWW*BBB$

本题的任务就是已知初始局面，询问**至少需要几步**，才能跳成另一个目标局面。

### 输入描述

输入为 2 行，2 个串，表示初始局面和目标局面。我们约定，输入的串的长度不超过 15。

### 输出描述

输出要求为一个整数，表示至少需要多少步的青蛙跳。

### 输入输出样例

#### 示例

> 输入

```txt
*WWBB
WWBB*
```

> 输出

```txt
2
```

## 分析

本题可使用**BFS**求解。BFS 的深度即为青蛙跳的步数。

青蛙的可跳步长的集合是 $D = \{-3, -2, -1, 1, 2, 3\}$ 。跳跃的本质是交换了青蛙和被子的所在位置。

搜索某个局面时，对每一个青蛙进行遍历，然后考虑这个青蛙与周围的位置进行交换。如果该青蛙所将要跳的某个位置是空杯子，才会执行交换。但是，随着搜索空间的增加，对局面进行遍历的时间复杂度表现为指数级。因此，这种思维方法是不可行的。

正确的方法应该是采用逆向思维。先找到空杯子在哪里，然后考虑这个空杯子与周围的青蛙进行交换。这样可以使得对局面进行遍历的时间复杂度表现为常数级。

### Python 版优化历程

V2 在局面的表示方法和位置的交换方法上进行的主要改进是，把“字符串内的字符交换”变成了“纯数值运算”。

具体而言，就是把每一个字符先转换为数字，转换模式是 $* = 0, W = 1, B = 2$ 。然后，采用三进制来计算局面的总数值 $S = \sum{3^i A_i}$ ，其中 $i$ 表示字符的原始索引。这样，交换位置就可以使用加减法来实现了。

另外，V2 采用的其他重要的优化方法还有：维护一个存储“已经搜索过的局面”的集合，避免重复搜索；使用直接查表代替了 `pow()` 函数的频繁调用。

经过上述优化后的代码在普通 Python（即 CPython）中已经不会运行超时。
