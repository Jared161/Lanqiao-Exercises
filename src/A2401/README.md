# A2401 - 合法括号序列（Counting Valid Sequences）

![C++](https://img.shields.io/badge/C++-AC-green)

> 题目来源：高中同学问我的题目。

## 题目

### 题目描述

某种由方括号 `[ ]` 和圆括号 `( )` 组成的括号序列很有一番说法，规则如下：

1. 允许同类括号的配对的嵌套。例如 `(())` 是合法的。
2. 不能存在无法配对的括号。例如 `()` 是合法的，而 `)(` 是非法的。
3. 不能在某个括号的配对结束之前让其他括号开始配对。例如 `()[]` 是合法的，而 `([)]` 是非法的。
4. 允许圆括号的配对处于方括号的配对里面，但是反过来则不能。例如 `[()]` 是合法的，而 `([])` 是非法的。

给定一个括号序列，你需要计算：

1. 最少需要移除多少个括号，才能使之成为一个合法序列。
2. 在移除括号数量最少的情况下，有多少种可能的移除方式。

### 输入描述

输入为一个长度为 $N \ (1 \leq N \leq 24)$ 的字符串，表示一个给定的括号序列。

### 输出描述

输出两个整数 $X$ 和 $Y$，使用空格隔开。

$X$ 表示最少需要移除的括号数，$Y$ 表示对应的移除方式的数量。

如果怎样移除括号都无法让该序列成为合法序列，则输出 `none 0`。

### 输入输出样例

#### 示例 1

> 输入

```txt
([(])
```

> 输出

```txt
3 3
```

> 样例说明

移除后的可能的情况如下：

```txt
x[x]x
xx(x)
(xxx)
```

#### 示例 2

> 输入

```txt
()())()
```

> 输出

```txt
1 3
```

> 样例说明

移除后的可能的情况如下：

```txt
(x())()
()()x()
()(x)()
```

#### 示例 3

> 输入

```txt
)(
```

> 输出

```txt
none 0
```

## 分析

本题可以使用**枚举法**解决。

枚举 $mask \in [1, 2^{24} - 1]$ 的所有移除可能，然后检测移除后是否合法，最后找到所有可能的移除数量的最小值并进行累加。
