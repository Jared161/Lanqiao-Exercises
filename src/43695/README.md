# 43695 - 填字母游戏

![Python3](https://img.shields.io/badge/Python3-AC-green)

## 题目

### 题目描述

小明经常玩 LOL 游戏上瘾，一次他想挑战 K 大师，不料 K 大师说：

" 我们先来玩个空格填字母的游戏，要是你不能赢我，就再别玩 LOL 了。"

K 大师在纸上画了一行 $n$ 个格子，要小明和他交替往其中填入字母。

并且：

1. 轮到某人填的时候，只能在某个空格中填入 L 或 O。
2. 谁先让字母组成了 "LOL" 的字样，谁获胜。
3. 如果所有格子都填满了，仍无法组成 LOL，则平局。

小明试验了几次都输了，他很惭愧，希望你能用计算机帮他解开这个谜。

### 输入描述

本题的输入格式为：

第一行，数字 $n$ （ $n<10$ ），表示下面有 $n$ 个初始局面。

接下来， $n$ 行，每行一个串，表示开始的局面。

比如：`******` 表示有 6 个空格。`L****` 表示左边是一个字母 L，它的右边是 4 个空格。

### 输出描述

要求输出 $n$ 个数字，表示对每个局面，如果小明先填，当 K 大师总是用最强着法的时候，小明的最好结果。

- 1 表示能赢；
- -1 表示必输；
- 0 表示可以逼平。

### 输入输出样例

#### 示例

> 输入

```txt
4
***
L**L
L**L***L
L*****L
```

> 输出

```txt
0
-1
1
1
```

## 分析

本题的情景是一种双人有限博弈，应当使用**极小极大算法**解决。

极小极大算法用于计算双人博弈中的最优策略（最强着法）。在本题中，小明是极大化者，他需要尽可能增加自己的收益，而 K 大师是极小化者，他需要尽可能减少小明的收益。我们约定这里的“收益”指的是“小明的胜率”（1= 胜利，0.5= 平局，0= 失败）。

对于某一个局面 $S_n$ ，如果只需要行动一次就能填满所有格子，则选取能够实现极小极大化的行动 $A_i$ （填入 L 或 O），那么行动 $A_i$ 所导致的小明的胜率就是该局面的胜率；如果当前局面需要不止一次行动才能填满所有格子，则遍历所有可能的行动 $A_j$ （在哪个格子填入 L 或 O），并对行动 $A_j$ 导致的新局面 $S_{n+1}$ 进行递归（注意处理攻守交换），然后选取能够实现极小极大化的行动 $A_j$ 作为局面 $S_n$ 的胜率。

在编码实现上，应注意维护一个用于存储“已计算过胜率的局面”的集合，以避免重复的计算。两个局面相等的条件是进攻方相同且格子情况相同。

### Python 版优化历程

V2 做了如下改进来提升运行效率：

1. 在“选取能够实现极小极大化的行动”时，不应该将所有新局面的胜率都放到列表里，然后对列表计算最大或最小值，而是应该直接使用单个变量 $rate$ ：对于每个新局面的胜率 $new\_rate$ ，如果极大化者小明是进攻方且 $new\_rate > rate$ ，或者极小化者 K 大师是进攻方且 $new\_rate < rate$ ，那么就令 $rate = new\_rate$ 。这样可以避免对列表的操作所花费的时间和空间。
2. 在“选取能够实现极小极大化的行动”时，如果极大化者小明是进攻方且 $new\_rate = 1$ ，说明收益已经极大化到上限，此时直接结束当前局面的计算并返回 $rate = 1$ ；如果极小化者 K 大师是进攻方且 $new\_rate = 0$ ，说明收益已经极小化到下限，此时直接结束当前局面的计算并返回 $rate = 0$ 。
3. 不如将胜率空间 $\{0,0.5,1\}$ 映射到 $\{-1,0,1\}$ ，这样就可以直接打印函数返回值了，而且处理整数会比浮点数容易一点。
4. 不如将函数参数“进攻方标志” $atk\_sign$ 的数据类型由布尔（ $true,false$ 分别表示小明和 K 大师进攻）改为整数（ $1,-1$ 分别表示小明和 K 大师进攻）。这样做的话，那么 (1) 中所描述的条件判断就可以直接写成 $new\_rate \times atk\_sign > rate \times atk\_sign$ 。

经过上述优化后的代码在 CPython 中对测试用例已经不会运行超时。
