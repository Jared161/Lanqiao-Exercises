# 43701 - 密码脱落

![Python3](https://img.shields.io/badge/Python3-AC-green)

## 题目

### 题目描述

X 星球的考古学家发现了一批古代留下来的密码。

这些密码是由 A、B、C、D 四种植物的种子串成的序列。

仔细分析发现，这些密码串当初应该是前后对称的（也就是我们说的镜像串）。

由于年代久远，其中许多种子脱落了，因而可能会失去镜像的特征。

你的任务是：给定一个现在看到的密码串，计算一下从当初的状态，它要至少脱落多少个种子，才可能会变成现在的样子。

### 输入描述

输入一行，表示现在看到的密码串（长度不大于 1000）。

### 输出描述

要求输出一个整数，表示**至少**脱落了多少个种子。

### 输入输出样例

#### 示例 1

> 输入

```txt
ABCBA
```

> 输出

```txt
0
```

#### 示例 2

> 输入

```txt
ABDCDCBABC
```

> 输出

```txt
3
```

## 分析

本题应该使用二维的**线性规划**算法解决。

我们想要知道长度为 $n$ 的字符串 $s$ 成为镜像串所需要添加的最小字符数（下称“最小添加数”），将其记作 $x_n$ 。

假设去掉 $s$ 的左端或右端的一个字符后，得到的长度为 $n-1$ 的所有子串的最小添加数为 $x_{n-1}$ 的话，接下来分两种情况讨论：

1. $s$ 的左右两端字符相同，此时不需要做任何操作，则 $x_n = x_{n-1}$ 。
2. $s$ 的左右两端字符不同，此时需要把 $s$ 一端的一个字符复制到另一端来使得 $s$ 形成镜像串（例如 `XABA => XABAX`）则 $x_n = x_{n-1} + 1$ 。

那么，我们可以从长度为 2 的最小子串的最小添加数 $x_2$ 开始计算：要想计算 $x_2$ ，只需要截取字符串 $s$ 的所有长度为 2 的子串，计算各自的添加数：

设变量 `i` 和 `j` 分别为左右截取索引，并使得 `i` 和 `j` 形成的定长区间在 $s$ 上滑动，如下所示：

```
|ij-------------|
|-ij------------|
|--ij-----------|
...
|-------------ij|
```

将所有可能的 `i` 和 `j` 截取到的子串的添加数存入二维数组 $dp^i_j$ 中，并不断地递增子串长度进行迭代：

```
|i=====j--------|
|-i=====j-------|
|--i=====j------|
...
|--------i=====j|
```

直到最后：

```
|i============j-|
|-i============j|
```

此时 $x_{n-1}$ 就可以得知了， $x_n$ 也就唾手可得。
